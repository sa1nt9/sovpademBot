"use strict";var __awaiter=this&&this.__awaiter||function(e,r,i,o){return new(i||(i=Promise))((function(t,s){function l(e){try{d(o.next(e))}catch(e){s(e)}}function n(e){try{d(o.throw(e))}catch(e){s(e)}}function d(e){var r;e.done?t(e.value):(r=e.value,r instanceof i?r:new i((function(e){e(r)}))).then(l,n)}d((o=o.apply(e,r||[])).next())}))};Object.defineProperty(exports,"__esModule",{value:!0}),exports.getLikesCount=getLikesCount,exports.getLikesInfo=getLikesInfo;const postgres_1=require("../../db/postgres"),logger_1=require("../../logger");function getLikesCount(e,r){return __awaiter(this,void 0,void 0,(function*(){try{if(logger_1.logger.info({targetId:e,type:r},"Getting likes count"),"user"===r){const r=yield postgres_1.prisma.$queryRaw`
                SELECT id, "profileType" FROM (
                    SELECT id, 'RELATIONSHIP'::text as "profileType" FROM "RelationshipProfile" WHERE "userId" = ${e}
                    UNION ALL
                    SELECT id, 'SPORT'::text as "profileType" FROM "SportProfile" WHERE "userId" = ${e}
                    UNION ALL
                    SELECT id, 'GAME'::text as "profileType" FROM "GameProfile" WHERE "userId" = ${e}
                    UNION ALL
                    SELECT id, 'HOBBY'::text as "profileType" FROM "HobbyProfile" WHERE "userId" = ${e}
                    UNION ALL
                    SELECT id, 'IT'::text as "profileType" FROM "ItProfile" WHERE "userId" = ${e}
                ) as profiles
            `,i=(yield postgres_1.prisma.profileLike.findMany({where:{fromProfileId:{in:r.map((e=>e.id))}},select:{toProfileId:!0}})).map((e=>e.toProfileId));return yield postgres_1.prisma.profileLike.count({where:{toProfileId:{in:r.map((e=>e.id))},liked:!0,fromProfileId:{notIn:i}}})}{const r=(yield postgres_1.prisma.profileLike.findMany({where:{fromProfileId:e},select:{toProfileId:!0}})).map((e=>e.toProfileId));return yield postgres_1.prisma.profileLike.count({where:{toProfileId:e,liked:!0,fromProfileId:{notIn:r}}})}}catch(i){return logger_1.logger.error({error:i,targetId:e,type:r},"Error in getLikesCount"),0}}))}function getLikesInfo(e,r){return __awaiter(this,void 0,void 0,(function*(){try{if(logger_1.logger.info({targetId:e,type:r},"Getting likes info"),"user"===r){const r=yield postgres_1.prisma.$queryRaw`
                SELECT id, "profileType" FROM (
                    SELECT id, 'RELATIONSHIP'::text as "profileType" FROM "RelationshipProfile" WHERE "userId" = ${e}
                    UNION ALL
                    SELECT id, 'SPORT'::text as "profileType" FROM "SportProfile" WHERE "userId" = ${e}
                    UNION ALL
                    SELECT id, 'GAME'::text as "profileType" FROM "GameProfile" WHERE "userId" = ${e}
                    UNION ALL
                    SELECT id, 'HOBBY'::text as "profileType" FROM "HobbyProfile" WHERE "userId" = ${e}
                    UNION ALL
                    SELECT id, 'IT'::text as "profileType" FROM "ItProfile" WHERE "userId" = ${e}
                ) as profiles
            `,i=(yield postgres_1.prisma.profileLike.findMany({where:{fromProfileId:{in:r.map((e=>e.id))}},select:{toProfileId:!0}})).map((e=>e.toProfileId)),o=yield postgres_1.prisma.profileLike.findMany({where:{toProfileId:{in:r.map((e=>e.id))},liked:!0,fromProfileId:{notIn:i}}}),t=o.length,s=o.reduce(((e,r)=>(e[r.profileType]||(e[r.profileType]=[]),e[r.profileType].push(r.fromProfileId),e)),{}),l=new Set;for(const[e,r]of Object.entries(s)){let i;switch(e){case"RELATIONSHIP":i=yield postgres_1.prisma.relationshipProfile.findMany({where:{id:{in:r}},include:{user:{select:{gender:!0}}}});break;case"SPORT":i=yield postgres_1.prisma.sportProfile.findMany({where:{id:{in:r}},include:{user:{select:{gender:!0}}}});break;case"GAME":i=yield postgres_1.prisma.gameProfile.findMany({where:{id:{in:r}},include:{user:{select:{gender:!0}}}});break;case"HOBBY":i=yield postgres_1.prisma.hobbyProfile.findMany({where:{id:{in:r}},include:{user:{select:{gender:!0}}}});break;case"IT":i=yield postgres_1.prisma.itProfile.findMany({where:{id:{in:r}},include:{user:{select:{gender:!0}}}})}null==i||i.forEach((e=>{l.add(e.user.gender||"male")}))}let n;return n=1===l.size?l.has("female")?"female":"male":"all",{count:t,gender:n}}{const r=(yield postgres_1.prisma.profileLike.findMany({where:{fromProfileId:e},select:{toProfileId:!0}})).map((e=>e.toProfileId)),i=yield postgres_1.prisma.profileLike.findMany({where:{toProfileId:e,liked:!0,fromProfileId:{notIn:r}}}),o=i.length,t=i.reduce(((e,r)=>(e[r.profileType]||(e[r.profileType]=[]),e[r.profileType].push(r.fromProfileId),e)),{}),s=new Set;for(const[e,r]of Object.entries(t)){let i;switch(e){case"RELATIONSHIP":i=yield postgres_1.prisma.relationshipProfile.findMany({where:{id:{in:r}},include:{user:{select:{gender:!0}}}});break;case"SPORT":i=yield postgres_1.prisma.sportProfile.findMany({where:{id:{in:r}},include:{user:{select:{gender:!0}}}});break;case"GAME":i=yield postgres_1.prisma.gameProfile.findMany({where:{id:{in:r}},include:{user:{select:{gender:!0}}}});break;case"HOBBY":i=yield postgres_1.prisma.hobbyProfile.findMany({where:{id:{in:r}},include:{user:{select:{gender:!0}}}});break;case"IT":i=yield postgres_1.prisma.itProfile.findMany({where:{id:{in:r}},include:{user:{select:{gender:!0}}}})}null==i||i.forEach((e=>{s.add(e.user.gender||"male")}))}let l;return l=1===s.size?s.has("female")?"female":"male":"all",{count:o,gender:l}}}catch(i){return logger_1.logger.error({error:i,targetId:e,type:r},"Error in getLikesInfo"),{count:0,gender:"all"}}}))}