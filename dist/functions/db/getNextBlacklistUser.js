"use strict";var __awaiter=this&&this.__awaiter||function(e,t,r,i){return new(r||(r=Promise))((function(s,n){function o(e){try{l(i.next(e))}catch(e){n(e)}}function a(e){try{l(i.throw(e))}catch(e){n(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(o,a)}l((i=i.apply(e,t||[])).next())}))};Object.defineProperty(exports,"__esModule",{value:!0}),exports.getNextBlacklistUser=void 0;const postgres_1=require("../../db/postgres"),getNextBlacklistUser=(e,t)=>__awaiter(void 0,void 0,void 0,(function*(){var r;const i=String(null===(r=e.from)||void 0===r?void 0:r.id);try{const e=yield postgres_1.prisma.blacklist.findFirst({where:{userId:i,targetProfileId:t},select:{createdAt:!0}});if(!e)return{user:null,remainingCount:0};const[r,s]=yield Promise.all([postgres_1.prisma.blacklist.findFirst({where:{userId:i,targetProfileId:{not:t},createdAt:{lt:e.createdAt}},orderBy:{createdAt:"desc"}}),postgres_1.prisma.blacklist.count({where:{userId:i,createdAt:{lt:e.createdAt}}})]);return{user:(yield postgres_1.prisma.user.findUnique({where:{id:null==r?void 0:r.targetUserId}}))||null,remainingCount:s}}catch(e){return console.error("Error getting next blacklist user:",e),{user:null,remainingCount:0}}}));exports.getNextBlacklistUser=getNextBlacklistUser;