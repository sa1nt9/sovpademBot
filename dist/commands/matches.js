"use strict";var __awaiter=this&&this.__awaiter||function(e,r,o,t){return new(o||(o=Promise))((function(i,s){function a(e){try{l(t.next(e))}catch(e){s(e)}}function n(e){try{l(t.throw(e))}catch(e){s(e)}}function l(e){var r;e.done?i(e.value):(r=e.value,r instanceof o?r:new o((function(e){e(r)}))).then(a,n)}l((t=t.apply(e,r||[])).next())}))};Object.defineProperty(exports,"__esModule",{value:!0}),exports.matchesCommand=void 0;const keyboards_1=require("../constants/keyboards"),postgres_1=require("../db/postgres"),grammy_1=require("grammy"),formatDate_1=require("../functions/formatDate"),client_1=require("@prisma/client"),profilesService_1=require("../functions/db/profilesService"),matchesCommand=e=>__awaiter(void 0,void 0,void 0,(function*(){var r;const o=String(null===(r=e.message)||void 0===r?void 0:r.from.id);e.logger.info({userId:o},"Starting matches command");if(yield postgres_1.prisma.user.findUnique({where:{id:o}})){e.session.step="sleep_menu";const r=e.session.activeProfile.profileType||client_1.ProfileType.RELATIONSHIP,t=(0,profilesService_1.getProfileModelName)(r),i=yield postgres_1.prisma[t].findFirst({where:{userId:o}}),s=(null==i?void 0:i.id)||"";if(!s)return e.logger.warn({userId:o},"No active profile found"),void(yield e.reply(e.t("no_active_profile")));const a=yield postgres_1.prisma.profileLike.findMany({where:{fromProfileId:s,liked:!0,isMutual:!0},orderBy:{createdAt:"desc"},take:101});if(0===a.length)return e.session.step="form_disabled",e.logger.info({userId:o},"No matches found"),void(yield e.reply(e.t("no_matches"),{reply_markup:(0,keyboards_1.formDisabledKeyboard)(e.t)}));e.logger.info({userId:o,matchesCount:a.length},"Found matches");let n=a.length>100?e.t("matches_message_last"):e.t("matches_message_all")+"\n\n";const l=new grammy_1.InlineKeyboard,d=5;for(let r=0;r<a.length;r++){const t=a[r],i=(0,profilesService_1.getProfileModelName)(t.profileType);try{const o=yield postgres_1.prisma[i].findUnique({where:{id:t.toProfileId},include:{user:!0}});if(!o||!o.user)continue;const s=o.user.id,a=o.user.name,m=yield e.api.getChat(s);n+=`${r+1}. [${a}](${m.username?`https://t.me/${m.username}`:""}) - ${(0,formatDate_1.formatDate)(t.isMutualAt||t.createdAt)}, ${e.t(`profile_type_${t.profileType.toLowerCase()}`)}\n`,r%d==0&&0!==r&&l.row(),l.text(`${r+1}. ${a}, ${e.t(`profile_type_${t.profileType.toLowerCase()}`)}`,`match:${s}`)}catch(r){e.logger.error({userId:o,targetProfileId:t.toProfileId,error:r instanceof Error?r.message:"Unknown error"},"Error retrieving profile or chat data");continue}}n+=`\n${e.t("matches_message_choose")}`,yield e.reply(n,{parse_mode:"Markdown",link_preview_options:{is_disabled:!0},reply_markup:l}),yield e.reply(e.t("sleep_menu"),{reply_markup:(0,keyboards_1.profileKeyboard)()})}else e.session.step="you_dont_have_form",e.logger.warn({userId:o},"User tried to view matches without profile"),yield e.reply(e.t("you_dont_have_form"),{reply_markup:(0,keyboards_1.notHaveFormToDeactiveKeyboard)(e.t)})}));exports.matchesCommand=matchesCommand;